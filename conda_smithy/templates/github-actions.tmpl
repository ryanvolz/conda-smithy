# This file was generated automatically from conda-smithy. To update this configuration,
# update the conda-forge.yml and/or the recipe/meta.yaml.
# -*- mode: yaml -*-

{%- set platformset = [] %}
{%- for data in configs %}
  {%- set pfarchless = data.build_platform.split('-')[0] %}
  {%- if pfarchless not in platformset %}
    {%- do platformset.append(pfarchless) %}
  {%- endif %}
{%- endfor %}

name: Build conda package
on: [push, pull_request]

jobs:
  build:
    name: {% raw %}${{ matrix.CONFIG }}{% endraw %}
    runs-on: {% raw %}${{ matrix.os }}{% endraw %}-latest
    strategy:
      fail-fast: false
      matrix:
        include:
        {%- for data in configs %}
          - CONFIG: {{ data.config_name }}
        {%- if github_actions.store_build_artifacts %}
            SHORT_CONFIG: {{ data.short_config_name }}
        {%- endif %}
            UPLOAD_PACKAGES: {{ data.upload }}
        {%- if data.build_platform.startswith("osx") %}
            os: macos
        {%- elif data.build_platform.startswith("linux") %}
            DOCKER_IMAGE: {{ data.config["docker_image"][-1] }}
            os: ubuntu
        {%- elif data.build_platform.startswith("win") %}
            os: windows
        {%- endif %}
        {%- endfor %}
    steps:
    - name: Checkout code
      uses: actions/checkout@v2
{%- if clone_depth is not none %}
      with:
        fetch-depth: {{ clone_depth }}
{%- endif %}

    - name: Build on Linux
      if: matrix.os == 'ubuntu'
      env:
        CONFIG: {% raw %}${{ matrix.CONFIG }}{% endraw %}
        UPLOAD_PACKAGES: {% raw %}${{ matrix.UPLOAD_PACKAGES }}{% endraw %}
        DOCKERIMAGE: {% raw %}${{ matrix.DOCKERIMAGE }}{% endraw %}
        CI: github_actions
{%- if upload_on_branch %}
        UPLOAD_ON_BRANCH: {{ upload_on_branch }}
{%- endif %}
{%- if docker.run_args is defined %}
        CONDA_FORGE_DOCKER_RUN_ARGS: "{{ docker.run_args }}"
{%- endif %}
{%- for secret in secrets %}
        {{ secret }}: {% raw %}${{{% endraw %} secrets.{{ secret }} {% raw %}}}{% endraw %}
{%- endfor %}
      shell: bash
      run: |
        echo "::group::Configure binfmt_misc"
        docker run --rm --privileged multiarch/qemu-user-static:register --reset --credential yes
        export FEEDSTOCK_NAME="$(basename $GITHUB_REPOSITORY)"
        export GIT_BRANCH="$(basename $GITHUB_REF)"
        echo "::endgroup::"
        ./.scripts/run_docker_build.sh

    - name: Build on macOS
      if: matrix.os == 'macos'
      env:
        CONFIG: {% raw %}${{ matrix.CONFIG }}{% endraw %}
        UPLOAD_PACKAGES: {% raw %}${{ matrix.UPLOAD_PACKAGES }}{% endraw %}
        CI: github_actions
{%- if upload_on_branch %}
        UPLOAD_ON_BRANCH: {{ upload_on_branch }}
{%- endif %}
{%- for secret in secrets %}
        {{ secret }}: {% raw %}${{{% endraw %} secrets.{{ secret }} {% raw %}}}{% endraw %}
{%- endfor %}
      shell: bash
      run: |
        export FEEDSTOCK_NAME="$(basename $GITHUB_REPOSITORY)"
        export GIT_BRANCH="$(basename $GITHUB_REF)"
        ./.scripts/run_osx_build.sh

{%- for choco_pkg in choco %}
    - name: "Install Chocolatey Package: {{ choco_pkg }}"
      if matrix.os == 'windows'
      run: |
        choco install {{ choco_pkg }} -fdv -y --debug
{% endfor %}

    - name: Install Miniconda for windows
      uses: conda-incubator/setup-miniconda@v2
      with:
        miniconda-version: latest
      if: matrix.os == 'windows'

    - name: Build on windows
      shell: cmd
      run: |
        call activate base
        conda.exe install -c conda-forge 'python=3.6' conda-build conda "{{ remote_ci_setup }}" pip {{- ' boa' if build_with_mambabuild else '' }}
        if errorlevel 1 exit 1
        {%- if local_ci_setup %}
        conda.exe uninstall --quiet --yes --force "{{ remote_ci_setup }}"
        if errorlevel 1 exit 1
        pip install --no-deps ".\{{ recipe_dir }}\."
        if errorlevel 1 exit 1
        {%- endif %}
        setup_conda_rc .\ ".\{{ recipe_dir }}" .\.ci_support\%CONFIG%.yaml
        if errorlevel 1 exit 1
        {% if build_setup -%}
        {{ build_setup.replace("\n", "\n        ").rstrip() }}
        {%- endif %}

        {%- if build_with_mambabuild %}
        conda.exe mambabuild "{{ recipe_dir }}" -m .ci_support\%CONFIG%.yaml
        exit 1
        {%- else %}
        conda.exe build "{{ recipe_dir }}" -m .ci_support\%CONFIG%.yaml
        if errorlevel 1 exit 1
        {%- endif %}
        set "FEEDSTOCK_NAME=%GITHUB_REPOSITORY:*/=%"
        set "GIT_BRANCH=%GITHUB_REF:refs/heads/=%"
        {%- if conda_forge_output_validation %}
        validate_recipe_outputs "%FEEDSTOCK_NAME%"
        if errorlevel 1 exit 1
        {%- endif %}
        if /i "%UPLOAD_PACKAGES%" == "true" (
          upload_package {% if conda_forge_output_validation %}--validate --feedstock-name="%FEEDSTOCK_NAME%"{% endif %}{% if private_upload %} --private{% endif %} .\ ".\{{ recipe_dir }}" .ci_support\%CONFIG%.yaml
        )
      env:
        PYTHONUNBUFFERED: 1
        CONFIG: {% raw %}${{ matrix.CONFIG }}{% endraw %}
        CI: github_actions
        UPLOAD_PACKAGES: {% raw %}${{ matrix.UPLOAD_PACKAGES }}{% endraw %}
{%- if upload_on_branch %}
        UPLOAD_ON_BRANCH: {{ upload_on_branch }}
{%- endif %}
{%- for secret in secrets %}
        {{ secret }}: {% raw %}${{{% endraw %} secrets.{{ secret }} {% raw %}}}{% endraw %}
      if: matrix.os == 'windows'
{%- endfor %}

{%- if github_actions.store_build_artifacts %}
    - name: Prepare conda build artifacts
      id: prepare-artifacts
      shell: bash
      if: {% raw %}${{ always() }}{% endraw %}
      env:
        CONFIG: {% raw %}${{ matrix.CONFIG }}{% endraw %}
        SHORT_CONFIG: {% raw %}${{ matrix.SHORT_CONFIG }}{% endraw %}
        OS: {% raw %}${{ matrix.os }}{% endraw %}
      run: |
        set -x

        # Use different prefix for successful and failed build artifacts
        # so random failures don't prevent rebuilds from creating artifacts.
        JOB_STATUS="{% raw %}${{ job.status }}{% endraw %}"
        if [ $JOB_STATUS == "failure" ]; then
          ARTIFACT_PREFIX="conda_artifacts"
        else
          ARTIFACT_PREFIX="conda_pkgs"
        fi

        # Set the artifact name, specialized for this particular job run.
        ARTIFACT_NAME="${ARTIFACT_PREFIX}_${GITHUB_RUN_ID}_${CONFIG}"
        if [[ {% raw %}${#ARTIFACT_NAME}{% endraw %} -gt 80 ]]; then
          ARTIFACT_NAME="${ARTIFACT_PREFIX}_${GITHUB_RUN_ID}_${SHORT_CONFIG}"
        fi
        echo "::set-output name=ARTIFACT_NAME::$ARTIFACT_NAME"

        # Check that the conda-build directory exists for archiving.
        if [ $OS == "macos" ]; then
          ARTIFACT_DIR="${MINIFORGE_HOME:-${HOME}/miniforge3}/conda-bld"
        elif [ $OS == "windows" ]; then
          ARTIFACT_DIR="${CONDA//\\//}/conda-bld"
        else
          ARTIFACT_DIR="build_artifacts"
        fi
        if [ ! -d "$ARTIFACT_DIR" ]; then
          echo "conda-build directory does not exist" 1>&2
          exit 1
        fi

        # Create a zip archive to use as the artifact.
        # (zip is not available on Windows container)
        # (7z is not present on macOS, mangled as part of Homebrew)
        ARTIFACT_ZIP="${ARTIFACT_NAME}.zip"
        if [ $OS == "windows" ]; then
          7z a "$ARTIFACT_ZIP" "$ARTIFACT_DIR" '-xr!.git/' '-xr!_*_env*/' '-xr!*_cache/'
        else
          cd "$ARTIFACT_DIR"
          zip -r -y -q "$GITHUB_WORKSPACE/$ARTIFACT_ZIP" . -x '*.git/*' '*_*_env*/*' '*_cache/*'
        fi
        echo "::set-output name=ARTIFACT_PATH::$ARTIFACT_ZIP"
      continue-on-error: true

    - name: Store conda build artifacts
      uses: actions/upload-artifact@v2
      if: {% raw %}${{ always() && steps.prepare-artifacts.outcome == 'success' }}{% endraw %}
      with:
        name: {% raw %}${{ steps.prepare-artifacts.outputs.ARTIFACT_NAME }}{% endraw %}
        path: {% raw %}${{ steps.prepare-artifacts.outputs.ARTIFACT_PATH }}{% endraw %}
        retention-days: {{ github_actions.artifact_retention_days }}
      continue-on-error: true
{%- endif %}
